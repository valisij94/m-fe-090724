# README

## Практическое занятие №30

Репозитарий содержит материалы по практическому занятию №31, посвященному знакомству с библиотекой `redux-toolkit`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Мотивационная часть, зачем это нужно
Казалось бы, зачем нам еще какие-то "библиотеки над библиотеками", когда уже есть готовый редакс, который прекрасно работает? Вопрос в целом логичный, но со своими нюансами. Основной момент - при работе с "чистым" редаксом, нужно писать огромное количество шаблонного (`boilerplate`) кода. Создатели экшнов, очень однотипные редьюсеры, сложные и громоздкие определения нового состояния на основе предыдущего, и так далее. Это все прекрасно работает, но довольно объемно. Сегодня мы рассмотрим библиотеку, которая "под капотом" работает так же, но снимает с нас большую часть необходимости по написанию шаблонного кода.

Более того, на официальном сайте редакса, в их документации в разделе [Quick Start](https://react-redux.js.org/tutorials/quick-start), они сами рекомендуют работать с этой библиотекой.

Для того, чтобы работать с библиотекой, надо ее установить. Она уже есть в проекте. Если вы хотите добавить ее в новый проект, установите командой `npm install @reduxjs/toolkit`.

### Работа с библиотекой
А дальше, все очень похоже на то, что мы делали ранее. Суть и результаты ровно те же. Разница только в объеме кода.

Первое, что нужно сделать - это создать `store`, то есть создать редакс-хранилище. Ранее, мы делали это deprecated-функцией `createStore`. Теперь, мы будем использовать то, что рекомендует нам документация редакс.

```
// src/redux/store.js

import { configureStore } from '@reduxjs/toolkit'

export default configureStore({
  reducer: {},
})
```

Пока что, в роли редьюсера мы передаем пустой объект, то есть наш стор работать не будет. Мы это исправим в ближайшем будущем.

Что мы делали дальше при работе со стандартным редаксом? Мы определяли типы экшнов, определяли функции-создатели экшнов, и делали редьюсеры. Причем, это все разносилось по разным файлам. Теперь, библиотека `@reduxjs/toolkit` минимизирует объем написанного кода.

Давайте рассмотрим на примере счетчика. **Пример взят с официальной документации!!!**

Ранее, в нашем приложении у нас был фрагмент редакс-стейта, который отвечал за счетчик (то есть просто счетчик кликов). У нас был файл `counterActions.js`, который содержал все, что касалось экшнов. А также, у нас был файл `counterReducer.js`, который отвечал за определение редьюсера, который и создавал нам фрагмент стейта с информацией о счетчике.

**Определение** Ранее, мы оперировали понятием "фрагмент состояния". В библиотеке `@reduxjs/toolkit`, используется термин `slice`, или "срез" состояния. Суть одна и та же - какой-то кусок состояния приложения, ответственный за какую-то его часть.

И наша задача - определить "слайс" состояния, который будет отвечать за счетчик. Сделаем это. Для этого, в папке `src/redux`, создадим папку `slices`, в которой мы будем определять слайсы нашего состояния приложения.

```
// src/redux/slices/counterSlice.js
import { createSlice } from '@reduxjs/toolkit'

export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
  },
  reducers: {
    increment: (state) => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes.
      // Also, no return statement is required from these functions.
      state.value += 1
    },
    decrement: (state) => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    },
  },
})

// Action creators are generated for each case reducer function
export const { increment, decrement, incrementByAmount } = counterSlice.actions

export default counterSlice.reducer
```

И этот файл содержит все, что нужно для создания фрагмента (слайса) состояния. Он создаст и редьюсер, и экшны, и функции-создатели экшнов. Наша задача - только этим пользоваться. Разберем подробнее.

1. Мы видим, что мы создаем "слайс" вызовом функции `createSlice`, которую импортируем из библиотеки. Эта функция принимает в аргументе большой объект с настройками фрагмента состояния.
2. Свойство `name` - обязательное, оно будет использоваться как префикс для типов экшнов, определенных в этом слайсе.
3. Свойство `initialState` - начальное состояние этого фрагмента стейта.
4. Свойство `reducers` - ответственно за создание и редьюсера, и экшнов. Это должен быть объект, свойствами которого будут имена экшнов. А значениями этих свойств - действия редьюсера, которые должны происходить при наступлении этого экшна. Например, мы видим там свойство `increment`. Это значит, что мы говорим: "у нас будет экшн increment". Это свойство содержит значение - функцию-колбэк, которая принимает стейт. И это - то, что происходит, когда диспатчится экшн `increment`. То есть, эта функция определяет новое состояние, в которое должен перейти этот фрагмент стейта при наступлении экшна `increment`.

Мы можем заметить одну ОЧЕНЬ непривычную вещь: все функции-колбэки в экшнах МУТИРУЮТ текущий стейт, и НИЧЕГО не возвращают! Это совершенно нормально для нашей библиотеки: в ней "под капотом" используется библиотека `Immer`, которая как раз и отвечат за иммутабельность объекта стейта. То есть, "под капотом", библиотека будет создавать новые объекты состояния.

5. Если нам нужна какая-то полезная нагрузка в экшне, то мы ее будем именовать как `payload`. Это видно из последнего экшна, `incerementByAmount`.
6. Мы делаем именованный экспорт экшнов в предпоследней строке нашего файла, причем экспортируем их как деструктуризацию `counterSlice.actions`. Это значит, что функция `createSlice` создает объект, у которого в числе прочего есть свойство `actions`, которое и содержит те `action-creator`-ы, которые мы определили в слайсе.
7. И финальный штрих - экспортируем свойство `counterSlice.reducer`. Он нам пригодится при создании стора.

Теперь, нам осталось добавить этот редьюсер в стор, чтобы он знал о фрагменте стейта `counter`.

```
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from './slices/counterSlice.js'

export default configureStore({
  reducer: {
    counter: counterReducer,
  },
})
```

И вот теперь, наш стейт приложения имеет свойство `counter`, в котором будет то, что нам возвращает редьюсер из `counterSlice`.

Вот и все! Выглядит намного короче, чем привычный редакс, не так ли?

Использование этого ничем не отличается от того, что мы делали со стандартным редаксом, то есть нам по-прежнему нужно:
 - обернуть приложение в `<Provider store={store}></Provider>`
 - использовать `useSelector` в компонентах, где нам нужно получить какие-то данные из стейта
 - использовать `useDispatch` в компонентах, где нам нужно "задиспатчить" экшн.

Чтобы "задиспатчить" экшн, нам нужно импортировать его из `counterSlice.js`, и задиспатчить. Например, так:
```
import { useDispatch, useSelector } from "react-redux"
import { increment, decrement, incrementByAmount } from "../../redux/slices/counterSlice";
import { useState } from "react";

export default function Counter() {

  const counter = useSelector(state => state.counter);
  const dispatch = useDispatch();

  const increment = () => {
    dispatch( increment() );
  }

  const decrement = () => {
    dispatch( decrement() );
  }

  const [inputValue, setInputValue] = useState('');
  const onInputChange = (e) => {
    setInputValue(e.target.value);
  }

  const addBtnClickHandler = () => {
    const parsed = +inputValue;
    if (!Number.isNaN(parsed))
      dispatch( incrementByAmount(parsed) );
    setInputValue('');
  }

  return (
    <div>
      <p>Now counter is: {counter}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
      <input placeholder="number" onChange={onInputChange} value={inputValue}></input>
      <button onClick={addBtnClickHandler}>Add number</button>
    </div>
  )
}
```

Таким образом, мы получаем гораздо меньше шаблонного кода.

### Закрепим практикой
В качестве практики, нам предстоит переписать всю имеющуюся логику работы с редаксом на использование `@reduxjs/toolkit`.

### Полезные ссылки
[Quick Start](https://react-redux.js.org/tutorials/quick-start) - официальная документация. Это ДАЛЕКО не все возможности библиотеки, но для базового понимания их будет более чем достаточно.